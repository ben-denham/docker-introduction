<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Introduction to Docker - Catalyst Training</title>

        <meta name="author" content="Catalyst">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/catalyst.css" id="theme">
        <link rel="stylesheet" href="css/font-awesome.css">

        <!-- For syntax highlighting -->
        <!-- <link rel="stylesheet" href="lib/css/zenburn.css"> -->
        <link rel="stylesheet" href="lib/css/catalyst-syntax.css">

        <!-- If the query includes 'print-pdf', include the PDF print sheet -->
        <script>
            if( window.location.search.match( /print-pdf/gi ) ) {
                var link = document.createElement( 'link' );
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
                document.getElementsByTagName( 'head' )[0].appendChild( link );
            }
        </script>

        <style>
            /* Add the ability to omit slides from the printed version (has to be after the print include)*/
            @media print {
                .reveal .slides section.no-print {
                    display: none !important;
                    visibility: hidden !important;
                }
            }
        </style>
        <style>
            .reveal h1, .reveal h2, .reveal h3 {
                color: #ba2025;
            }
        </style>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->

        <!-- Please put any custom styles here -->
        <style>

        </style>
    </head>

    <body>

        <div class="reveal">

            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">
                <!-- Cover slide -->
                <section>
                    <h1 class="catalyst-logo">Catalyst</h1>
                    <h3>Intro to Docker</h3>
                    <p class="small-text">
                        Presented by <a href="#">Ben Denham</a>
                    </p>
                    <p class="small-text">
                        Slides by <a href="#">Donovan Jones</a>, <a href="#">Travis Holton</a>, and <a href="#">Ben Denham</a>
                    </p>
                </section>

                <section>
                    <h3>Administrivia</h3>
                    <ul>
                      <li>Bathrooms</li>
                      <li>Fire exits</li>
                    </ul>
                </section>

                <section>
                    <h3>This course</h3>
                    <ul>
                        <li>Makes use of official Docker docs</li>
                        <li>A mix of command line and theory</li>
                        <li>Assumes no prior Docker knowledge</li>
                        <li>Assumes familiarity with the linux shell</li>
                        <li>Assumes we are using ubuntu (trusty)</li>
                        <li>Has some helper scripts</li>
                    </ul>
                </section>

                <section>
                    <h3>Aims</h3>
                    <ul>
                        <li>Understand how to use Docker on the command line</li>
                        <li>Understand where Docker can be used</li>
                        <li>Appreciation of the larger ecosystem</li>
                        <li>Get peole thinking about where they could use Docker</li>
                        <li>Get people using the technology</li>
                    </ul>
                </section>
                <section>
                    <h3>Understanding Docker</h3>
                    <p><a
                        href="https://docs.docker.com/engine/understanding-docker/">https://docs.docker.com/engine/understanding-docker/</a> <a href="http://webcache.googleusercontent.com/search?q=cache:https://docs.docker.com/introduction/understanding-docker/">(cache)</a></p>
                    <aside class="notes">
                        <ul>
                      <li>Expalin architecture diagram (Commands and components).</li>
                      <li>Client vs daemon.</li>
                      <li>Union file systems; each command in a Dockerfile creates a new layer in an image.</li>
                      <li>Docker's use of UFS separates it from other container solutions.</li>
                      <li>Execute the "docker run" command and go through the list of steps it does.
                        <ul>
                          <li>Use sudo, unless you are in the Docker group (because of kernel feature permissions)</li>
                          <li>-i for interactive mode, -t for pseudo-tty allocation (Both let you use bash like a terminal)</li>
                        </ul></li>
                      <li>Namespaces => isolation of filesystem and kernel features.</li>
                      <li>Control groups => resource limiting.</li>
                      <li>Different container format avaialble, default is libcontainer</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>What is containerization?</h3>
                    <ul>
                        <li>
                            An operating system level virtualization method for
                            running distributed applications without launching an
                            entire VM.
                        </li>
                        <li>
                            Multiple isolated systems run on a single host and
                            access a single kernel
                        </li>
                        <li>
                            Key benefits:
                            <ul>
                                <li>Lightweight - Places less strain on overall resources.</li>
                                <li>Efficiency gains in storage, CPU</li>
                                <li>Portability
                                    <aside class="notes">
                                        Same application container can run on any system or cloud.
                                    </aside>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </section>

                <!-- Large image slide -->
                <section class="image-slide">
                    <h2>Lightweight</h2>
                    <img src="img/docker.png" alt="">
                    <aside class="notes">Remember: Docker containers are all tied to the same kernel.</aside>
                </section>

                <section>
                    <h3>Decoupling</h3>
                    <ul>
                        <li>Application stack is no longer coupled to machine it is running on</li>
                        <li>Allows a service to have the most appropriate stack without needing to consider conflicts with and dependencies of other services (eg python versions)</li>
                        <li>Services can be run in the most optimal location for a given organisation</li>
                        <li>Services can be upgraded and scaled independently</li>
                        <li>Services boundaries can define areas of responsibility</li>
                        <li>Configuration is coupled with the application</li>
                        <li>Service vs. Machine</li>
                    </ul>
                    <aside class="notes">Scale services, not machines. You *can* treat machines like cattle, not pets.</aside>
                </section>





                <section>
                    <h3>What is Docker?</h3>
                    <ul>
                        <li>Docker is an open-source platform for creating,
                            running, and distributing software "containers"
                            that bundle software applications with all of
                            their dependencies.

                            <li><a href="https://docs.docker.com/engine/understanding-docker/#what-is-the-docker-platform">Docker Platform</a></li>

                            <li><a href="https://docs.docker.com/engine/understanding-docker/#what-is-docker-engine">Docker Engine</a></li>
                        </li>

                    </ul>
                </section>


                <section>
                    <h3>Why Docker?</h3>
                    <ul>
                        <li>Containers generally lightweight compared to traditional virtualization</li>
                        <li>Consistency across dev/test/prod</li>
                        <li>Easy to modify, update and scale</li>
                        <li>Dependency encapsulation and decoupling</li>
                        <li>Enables (requires?) new workflows</li>
                    </ul>
                </section>
                <section>
                    <h3>Docker Portability</h3>

                    <ul>
                        <li>Any modern Linux (RHEL, CentOS, Ubuntu LTS, etc.), OSX, Windows</li>
                        <li>Lightweight Docker optimized Linux distributions (CoreOS, Project Atomic, RancherOS, etc.)</li>
                        <li>Private clouds (OpenStack, Vmware)</li>
                        <li>Public clouds (AWS, Azure, Rackspace, Google)</li>
                    </ul>

                </section>
                <section>
                    <h3>Docker popularity</h3>
                    <ul>
                        <li>Linux containers are not new, but Docker
                            makes it easier to build and ship them.</li>
                        <li>Containers are intended to do for software
                            deployment what the shipping container did for
                            the shipping industry.</li>
                    </ul>
                </section>

                <!-- Large image slide -->
                <section class="image-slide">
                    <h2>Simple Workflow</h2>
                    <img src="http://blog.octo.com/wp-content/uploads/2014/01/Diapositive1.png" alt="">
                    <aside class="notes"><ul>
                      <li>Docker workflows are comparable to Git workflows.</li>
                      <li>Always specify tags (or SHAs).</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>Docker Engine</h3>
                    <img src="img/engine-components-flow.png" alt="Ambassador">
                </section>


                <section>
                    <h3>Components of Docker</h3>
                    <ul>
                        <li>Images
                            <ul>
                                <li><strong>The build component</strong></li>
                                <li>Read only template for creating containers</li>
                                <li>
                                    Can be built and distributed (by anyone)
                                </li>
                                <li>Can be based on or extended by other
                                    images</li>
                            </ul>
                        </li>
                        <li>Containers
                            <ul>
                                <li><strong>The run component</strong></li>
                                <li>An actual running instance of an image</li>
                                <li>Read/write</li>
                                <li>Encasulates your application and its dependencies</li>
                            </ul>
                        </li>

                        <li>Registries
                            <ul>
                                <li><strong>The distribution component</strong></li>
                                <li>Repository of images</li>
                            </ul>
                        </li>
                    </ul>
                    <aside class="notes">Remember: Images are like templates/classes, containers are like instances/objects.</aside>
                </section>


                <!-- Large image slide -->
                <section class="image-slide">
                    <h2>Containers and Images</h2>
                    <img
                    src="http://alandargan.com/wp-content/uploads/2014/11/Docker2.png" alt="">
                </section>

                <section>
                    <h3>Scripts</h3>
                    <ul>
                        <li>Designed to be run on trusty training machines</li>
                        <li>docker-setup.sh - ensures required software is installed</li>
                        <li>user-setup.sh - sets up environment variables for our user</li>
                        <!--<li>docker-course.sh - list or run the course commands</li>-->
                    </ul>
                </section>

                <section>
                    <h3>Checkout code and examples</h3>
                    <pre><code data-trim contenteditable>
    $ git clone https://github.com/catalyst-training/docker-training
                    </code></pre>
                </section>
                <section>
                    <h3>Setup</h3>
                    <p>lets setup our environment now</p>
                    <pre><code data-trim contenteditable>
cd docker-training
source ./user-setup.sh
                    </code></pre>
                </section>
                <section>
                    <h3>Install Docker</h3>
                    <pre><code data-trim contenteditable>
    $ sudo ./docker-setup.sh
                    </code></pre>
                </section>
                <section>
                    <h3>Docker architecture</h3>
                    <pre>
    $ ps waux | grep dockerd
    $ sudo docker images</pre>

                    <img src="img/architecture.svg" alt="Architecture">
                </section>
                <!--
                <section>
                    <h3>Course script</h3>
                    <p>By default this script outputs all the commands you will need to run</p>
                    <pre><code data-trim contenteditable>
$ sudo ./docker-course.sh -h

Usage: sudo ./docker-course.sh [OPTIONS]

    -h        this help
    -s        takes an integer, indicates that we should stop at this section
    -r        replay, runs all the commands without user input
    -i        interactive replay, requires keypresses to run commands
                    </code></pre>
                    <p>try it now</p>
                    <pre><code data-trim contenteditable>
sudo ./docker-course.sh -s 3
                    </code></pre>
                </section>
                -->


                <section>
                  <h3>1: Getting Help</h3>

                  <pre><code># Check your Docker version (often important)
sudo docker version

# Get Docker command help
sudo docker --help
sudo docker run --help</code></pre>
                </section>

                <section>

                <section>
                  <h3>2: Working with Containers</h3>

                  <pre><code># Running a simple container
sudo docker run hello-world

# An interactive container
sudo docker run -t -i ubuntu:14.04 /bin/bash

# A daemonized container
sudo docker run --name=insane_babbage -d ubuntu:14.04 /bin/sh -c \
  "while true; do echo hello world; sleep 1; done"

sudo docker ps # List running containers (note container ids)
sudo docker stop insane_babbage # Stop a container
sudo docker ps -a # List non-running containers

sudo docker start insane_babbage # Restart
sudo docker rm insane_babbage # Delete the container</code></pre>
                </section>

                <section>
                  <h3>2: A Simple Web App</h3>

                  <pre><code>#Start a webserver daemon, exposing all ports (-P)
sudo docker run --name=nostalgic_morse -d -P \
    training/webapp python app.py

# View last running container
docker ps -l

# Command to get assigned port
docker port nostalgic_morse 5000

# Or you could assign it yourself (e.g. 5555 on host)
sudo docker run --name=nostalgic_morse -d -p 5555:5000 \
    training/webapp python app.py

sudo docker logs nostalgic_morse # View standard output; supports -f
sudo docker top nostalgic_morse # View container processes
sudo docker inspect nostalgic_morse # Inspect a container</code></pre>
                  <aside class="notes"><ul>
                    <li>Only non-official images have slashes in the name (which is the DockerHub account name)</li>
                    <li>Docker client defaults to DockerHub, but it can be made to point to another registry (but it is a bit tricky).</li>
                    <li>Note PORTS in docker ps output, custom mappings assigned with -p</li>
                  </ul></aside>
                </section>

                </section>

                <section>

                <section>
                    <h3>3: Get started with images</h3>

                    <pre><code># List images
sudo docker images

# Search for an image
sudo docker search sinatra

# Pull an image
sudo docker pull alpine:3.5

# Remove an image
sudo docker rmi alpine:3.5</code></pre>

                    <aside class="notes"><ul>
                      <li>Careful not to chew up space with too many images.</li>
                      <li>An image is a base image, plus all FS layers on top.</li>
                      <li>Talk about tags (default tag when none is specified is latest)</li>
                    </ul></aside>
                </section>

                <section>
                    <h3>3: Creating your own image</h3>

                    <pre><code>#Start a container
sudo docker run -t -i training/sinatra /bin/bash

# Run "gem install json" in the container and exit

# Commit the change as a new image layer
sudo docker commit -m "Added json gem" -a "Me" \
    $CONTAINER_ID me/sinatra:v1

# See the image
sudo docker images

# Run a new container from the image
sudo docker run -t -i me/sinatra:v1 /bin/bash</code></pre>
                </section>

                </section>

                <section>
                    <h3>4: Creating an image from a Dockerfile</h3>

                    <pre><code># Clone some source code
git clone https://github.com/docker-training/webapp
cd webapp

# Look at the Dockerfile
cat Dockerfile

# Build an image
sudo docker build -t me/webapp .

# Run a container
sudo docker run -d -p 5555:5000 me/webapp</code></pre>

                    <aside class="notes"><ul>
                      <li>Generally better to use a Dockerfile (it must have that name)</li>
                      <li>Each instruction in a Dockerfile creates a new layer.</li>
                      <li>Everything in the same directory as the Dockerfile is sent to the Docker daemon as "context" (so don't put a Dockerfile in your home directory).</li>
                      <li>To keep image sizes small, remove apt-cache (in the same instruction as installing dependencies), and remove other unnecessary cruft before it is added in a layer.</li>
                      <li>Max layers: 127</li>
                    </ul></aside>
                </section>

                <section>

                <section>
                    <h3>5: Managing data in containers</h3>
<a
    href="https://docs.docker.com/engine/tutorials/dockervolumes/">https://docs.docker.com/engine/tutorials/dockervolumes/</a> <a href="http://webcache.googleusercontent.com/search?q=cache:https://docs.docker.com/userguide/dockervolumes">(cache)</a>
                    <aside class="notes"><ul>
                      <li>Data volumes are like the "mount" command; they bypass the UFS.</li>
                      <li>You can mount a directory from the host, or just a standalone volume.</li>
                      <li>docker run -v /webapp OR specify in Dockerfile</li>
                      <li>You can set read-only permissions on a volume (:ro).</li>
                      <li>A container's volumes are not deleted when it is deleted.</li>
                      <li>docker inspect {container} (To see volume info under "Mounts")</li>
                      <li>docker run -v /src/webapp:/opt/webapp</li>
                      <li>host_directory:container_directory</li>
                      <li>You can mount individual files</li>
                      <li>Pattern: Put all your data volumes in a single container, then use --volumes-from to share them with other containers. This means that you can safely delete the other containers without losing a container with a reference to the volume.</li>
                      <li>To remove volumes along with a container, use: docker rm -v</li>
                      <li>Removing a container without removing volumes will create dangling volumes which will need to be manually deleted.</li>
                    </ul></aside>
                </section>

                <section>
                  <h3>5: Managing data in containers</h3>

                  <pre><code># Add a data volume to a container
docker run -d -P --name web -v /webapp training/webapp python app.py

# Locate the volume
docker inspect web

# Mount a host directory (or file) as a volume
sudo docker run -v $(pwd)/logs:/var/log -ti \
    training/webapp /bin/bash
sudo docker run -v ~/.bashrc:/root/.bashrc:ro -ti \
    training/webapp /bin/bash

# Mount shared storage as a volume
docker run --volume-driver=convoy -v my-named-volume:/webapp \
    training/webapp python app.py

# Using --volumes-from to backup volumes
docker run --rm --volumes-from web -v $(pwd):/backup \
    ubuntu tar cvf /backup/backup.tar /webapp

# List volumes
docker volume ls

# Remove unused volumes
docker volume prune</code></pre>

                </section>

                </section>

                <section>

                <section>
                    <h3>6: Publishing to Docker Hub/Cloud</h3>

                    <a href="https://docs.docker.com/docker-cloud/builds/push-images/">https://docs.docker.com/docker-cloud/builds/push-images/</a>

                    <pre><code>sudo docker login

# Tag your image
sudo docker tag my_image $DOCKER_USERNAME/my_image

# Push your image
sudo docker push $DOCKER_USERNAME/my_image</code></pre>

                    <aside class="notes"><ul>
                      <li>DockerHub has similar webhook and automation capabilities to GitHub.</li>
                    </ul></aside>
                </section>

                <section>
                    <h3>6: Pushing to a Docker Registry</h3>

                    <a href="https://docs.docker.com/registry/">https://docs.docker.com/registry/</a>

                    <pre><code># Run a registry
sudo docker run -d -p 5000:5000 --name registry registry:2

# Tag your image
sudo docker tag my_image localhost:5000/my_image

# Push your image to the registry
sudo docker push localhost:5000/my_image

# Pull an image from the registry
sudo docker pull localhost:5000/my_image</code></pre>

                    <aside class="notes"><ul>
                      <li>DockerHub has similar webhook and automation capabilities to GitHub.</li>
                    </ul></aside>
                </section>

                </section>
<!--
   -                <section>
   -                    <section>
   -                        <h2>Cookbook Examples</h2>
   -                    </section>
   -
   -                    <section>
   -                        <h3>Run Hello world in busy box</h3>
   -                        <pre> $ docker run busybox echo hello world
   -
   -Unable to find image 'busybox' locally
   -busybox:latest: The image you are pulling has been verified
   -511136ea3c5a: Pull complete
   -df7546f9f060: Pull complete
   -e433a6c5b276: Pull complete
   -e72ac664f4f0: Pull complete
   -Status: Downloaded newer image for busybox:latest
   -hello world
   -                        </pre>
   -                    </section>
   -
   -                    <section>
   -                        <h3>Run a container in detached mode</h3>
   -                        <pre>$ docker run -d  -p 1234:1234 python:3.5 python -u -m http.server 1234
   -Unable to find image 'python:3.5' locally
   -3.5: Pulling from library/python
   -8ad8b3f87b37: Pull complete
   -751fe39c4d34: Pull complete
   -ae3b77eefc06: Pull complete
   -7783aac582ec: Pull complete
   -b7fc86da4ddd: Pull complete
   -25af1114570f: Pull complete
   -fa675d7a898c: Pull complete
   -Digest: sha256:e73edc3b2c53fd775473ab99056a331dd719f914a8e8bd4e0a2e97bf1c95524e
   -Status: Downloaded newer image for python:3.5
   -b207c64501437c7f70c7d5fc6dacc2280cb860d67b966f03b98ce725ce23d128
   -                        </pre>
   -
   -                    </section>
   -                    <section>
   -                        <h3>Run a container in detached mode</h3>
   -                        <pre>$ docker ps
   -
   -CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
   -62e9b7c9be5b        python:3.5          "python -u -m http.se"   5 seconds ago       Up 4 seconds        0.0.0.0:1234->1234/tcp   berserk_murdock
   -
   -$ docker logs -f <container>
   -                        </pre>
   -                    </section>
   -
   -                </section>
   -->
                <section>
                <!-- Large image slide -->
                <section class="image-slide">
                    <h2>7: Layering (via a Union file system)</h2>
                    <img src="https://assets.digitalocean.com/articles/docker_ecosystem/Container-Overview.png" alt="">
                </section>
                <section>
                    <h3>7: Layers</h3>
                    <ul>
                        <li>dockviz</li>
                    <pre><code data-trim contenteditable>
sudo dockviz images --tree

sudo dockviz images -d | dot -Tpng -o images.png && eog images.png && rm images.png
sudo dockviz containers -d | dot -Tpng -o containers.png && eog containers.png && rm containers.png
                    </code></pre>
                    </ul>
                    <aside class="notes">Local tool to visualise layers.</aside>
                </section>

                <section>
                    <h3>7: imagelayers.io</h3>
                    <p><a href="https://imagelayers.io/?images=java:latest,golang:latest,node:latest,python:latest,php:latest,ruby:latest">https://imagelayers.io/</a><p>
                    <aside class="notes">Service to visualise layers.</aside>
                </section>

                <section>
                    <h3>7: Docker history</h3>
                    <p>Show the history (layers) of an image</p>
                    <pre><code data-trim contenteditable>
$ docker history cb7ea125b1fc
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
cb7ea125b1fc        3 months ago        /bin/sh -c gem install sinatra                  18.44 MB
0c0869a12bcd        3 months ago        /bin/sh -c apt-get update && apt-get install    112.7 MB
6d4946999d4f        3 months ago        /bin/sh -c #(nop) CMD ["/bin/bash"]             0 B
9fd3c8c9af32        3 months ago        /bin/sh -c sed -i 's/^#\s*\(deb.*universe\)$/   1.895 kB
435050075b3f        3 months ago        /bin/sh -c echo '#!/bin/sh' > /usr/sbin/polic   194.5 kB
428b411c28f0        3 months ago        /bin/sh -c #(nop) ADD file:b3447f4503091bb6bb   188.1 MB
                    </code></pre>
                </section>

                <section>
                    <h3>7: Docker Diff</h3>
                    <p>Show the differences between a container's filesystem and its base image</p>
                    <pre><code data-trim contenteditable>
$ sudo docker run --name=sleepy_cori -it ubuntu:latest /bin/bash
root@e888e0fef39e:/# echo flubber > test.txt
root@e888e0fef39e:/# exit

$ sudo docker ps -l
CONTAINER ID IMAGE         COMMAND     CREATED       STATUS                    PORTS NAMES
e888e0fef39e ubuntu:latest "/bin/bash" 2 minutes ago Exited (0) 25 seconds ago       sleepy_cori

$ sudo docker diff sleepy_cori | head
C /root
A /root/.bash_history
A /test.txt
C /tmp
C /usr
C /usr/bin
A /usr/bin/mtr
C /usr/share
C /usr/share/doc
A /usr/share/doc/mtr-tiny
                    </code></pre>
                    <aside class="notes">View changes to a container.</aside>
                </section>

                <section>
                    <h3>7: Docker Diff</h3>
                    <p>Show the differences between a container's filesystem and its base image</p>
                    <pre><code data-trim contenteditable>
$ sudo find /var/lib/docker/ -type f -name 'test.txt' -exec md5sum {} \;
185320c3e9298cdbde3320ec32144980  /var/lib/docker/aufs/diff/e888e0fef39e6f7f249f33f0475e891aaef899cca9ed0ea39d2524e5f06be792/test.txt

$ sudo docker restart sleepy_cori
sleepy_cori

$ sudo docker exec sleepy_cori md5sum test.txt
185320c3e9298cdbde3320ec32144980  test.txt
                    </code></pre>
                    <aside class="notes">Show that files inside container can be found in the host filesystem.</aside>
                </section>

                <section>
                    <h3>7: Docker Diff what is AUFS?</h3>
                    <ul>
                        <li>Did you notice /var/lib/docker/aufs?</li>
                        <li><a href="http://aufs.sourceforge.net/">Advanced Multi Layered Unification Filesystem</a></li>
                    <pre><code data-trim contenteditable>
priority = []string{
"aufs",
"btrfs",
"devicemapper",
"vfs",
"overlayfs",
                    </code></pre>
                        <li>Details <a href="https://developerblog.redhat.com/2014/09/30/overview-storage-scalability-docker/">here</a></li>
                    </ul>
                    <aside class="notes">Different UFS available, priority order shown above. The first available on a system will be used, but it is overridable. Not all OS distributions can use them all.</aside>
                </section>


                </section>

                <section>
                <section>
                    <h3>8: More on Dockerfiles</h3>
                    <ul>
                        <li><a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/">Dockerfile Best Practices</a></li>
                        <li><a href="https://labs.ctl.io/dockerfile-entrypoint-vs-cmd/">ENTRYPOINT vs CMD</a></li>
                    </ul>
                    <aside class="notes"><ul>
                      <li><strong>Dockerfile Best Practices</strong></li>
                      <li>Go over main points in recommendations</li>
                      <li>Explain layer caching, and cache-busting with changed lines and --no-cache=true</li>
                      <li>Never run apt-get upgrade or dist-upgrade (they may not work in a container), always depend on the base image to be updated.</li>
                      <li>Look at apt-get recommendations (update in same instruction, version pinning, clearing apt lists)</li>
                      <li>Prefer COPY instead of ADD (which has fancy features such as remote URLs and tar expansion)</li>
                      <li><strong>ENTRYPOINT vs CMD</strong></li>
                      <li>CMD is overriden by whatever the user supplies as the command.</li>
                      <li>ENTRYPOINT prefixes the command, so is good as a "wrapping command" for other subcommands. E.g. git</li>
                      <li>ENTRYPOINT can be overriden with --entrypoint</li>
                      <li>CMD can be used to contain default options for the ENTRYPOINT</li>
                      <li>Prefer CMD/ENTRYPOINT exec form (["/bin/ping" "-c" "3"]) over shell form ("ping -c 3", which is executed as "/bin/sh -c ping -c 3") so that the process itself is PID 1, not the shell (useful for Docker control signals).</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>8: Dockerfiles: ENTRYPOINT vs CMD</h3>
                    <ul>
                        <li>Lets look at some images: <a href="https://imagelayers.io/?images=debian:6,alpine:2.6">https://imagelayers.io/?images=debian:6,alpine:2.6</a></li>
                    <pre><code data-trim contenteditable>
$ sudo docker run -i -t debian
root@0f94a65e7d37:/# exit
$ sudo docker run -i -t alpine
Error response from daemon: No command specified
                    </code></pre>
                    </ul>
                </section>
                <section>
                    <h3>8: Dockerfiles: ENTRYPOINT vs CMD</h3>
                    <pre><code data-trim contenteditable>
$ cat dockerfiles/ping-localhost/dockerfile
FROM debian:jessie
CMD ping localhost
$ sudo docker build -t demo dockerfiles/ping-localhost
$ sudo docker run -t demo
PING localhost (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.034 ms
64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.054 ms
64 bytes from localhost (127.0.0.1): icmp_seq=3 ttl=64 time=0.064 ms
$ docker run demo uname -a
Linux fac4960db319 3.13.0-66-generic #108-Ubuntu SMP Wed Oct 7 15:20:27 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux
                    </code></pre>
                </section>
                <section>
                  <h3>8: Dockerfiles: ENTRYPOINT vs CMD</h3>
                  <pre><code data-trim contenteditable>
$ cat dockerfiles/ping-localhost-both/dockerfile
FROM debian:jessie
ENTRYPOINT ["/bin/ping","-c","3"]
CMD ["localhost"]
$ sudo docker build -t ping dockerfiles/ping-localhost-both
$ sudo docker run ping
$ sudo docker run ping google.com
$ sudo docker run --entrypoint="ls" ping
                  </code></pre>
                </section>
                <section>
                    <h3>8: Dockerfiles: ENTRYPOINT vs CMD</h3>
                    <ul>
                        <li>Use CMD when you want the user to have the choice of commands to run</li>
                        <li>Use ENTRYPOINT when you want to wrap a command</li>
                        <li>ENTRYPOINT can be overridden with the --entrypoint flag</li>
                    </ul>
                </section>
                <section>
                    <h3>8: Dockerfiles: Shell vs Exec Form</h3>
                    <ul>
                      <li>Shell form: <pre><code>CMD ping localhost</code></pre></li>
                      <li>Exec form: <pre><code>CMD ['/bin/ping','localhost']</code></pre></li>
                      <li>Prefer Exec, as your command will run as PID 1 (useful when sending POSIX signals), rather than an invocation of "/bin/sh -c"</li>
                    </ul>
                </section>
                </section>

                <section>
                    <h3>9: Base images</h3>
                    <ul>
                        <li>Size is a major consideration ... deploy times ...</li>
                        <li>FROM empty ...</li>
                        <li><a href="http://www.busybox.net/">Busybox</a> - 5.6 MB, no package manager</li>
                        <li><a href="https://www.alpinelinux.org/">Alpine Linux</a> - distribution of choice for minimal containers - 5MB with a package manager (based on busybox)</li>
                        <li><a href="https://hub.docker.com/_/debian/">Debian</a> - Reccomended by Docker, smaller than Ubuntu - 85MB</li>
                        <li><a href="https://hub.docker.com/_/ubuntu/">Ubuntu</a> - Commonly used but quite big</li>
                        <li>Language images (<a href="https://hub.docker.com/_/golang/">golang</a>, <a href="https://hub.docker.com/_/python/">python</a> etc.) - Seem to be mostly based on Debian</li>
                        <li>See <a href="http://www.blang.io/posts/2015-04_how-to-build-the-smallest-docker-containers">1</a>, <a href="http://www.livewyer.com/blog/2015/02/24/slimming-down-your-docker-containers-alpine-linux">2</a>, <a href="https://docs.docker.com/articles/baseimages/">3</a></li>
                    </ul>
                </section>

                <section>
                  <section>
                    <h3>10: Docker networking</h3>
                    <a
    href="https://docs.docker.com/engine/tutorials/networkingcontainers/">https://docs.docker.com/engine/tutorials/networkingcontainers/</a>
                    <aside class="notes"><ul>
                      <li>Networking used to be handled through "Docker links" (one way exposing of ports between containers), which are now deprecated.</li>
                      <li>docker run --name (Naming a container)</li>
                      <li>You can create networks for your containers to sit on (specifying a driver (e.g. bridge driver on local machine, overlay driver across machines))</li>
                      <li>You'll want to create your own networks to isolate containers from each other in more complex setups.</li>
                      <li>List networks with: docker network ls</li>
                      <li>"bridge" is a special network that all cotnainers are added to by default.</li>
                      <li>You can "docker inspect {network}" to find out container IP addresses</li>
                      <li>docker network create</li>
                      <li>docker network connect/disconnect</li>
                      <li>Start a container on a network with --net</li>
                      <li>Inspect a container to see network information (it can be on multiple networks).</li>
                      <li>Start 2 containers on the same network, and ping each other.</li>
                      <li>When you connect a container to a network, Docker updates /etc/hosts on the other hosts so they can refer to it by its container name.</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>10: Docker networking</h3>
                    <img src="http://www.linuxjournal.com/files/linuxjournal.com/ufiles/imagecache/large-550px-centered/u1002061/11833f1.png" alt="docker networking">
                    <aside class="notes"><ul>
                      <li>docker starts a "docker0" virtual bridge to handle host-container communication.</li>
                      <li>When a container starts, Docker creates a virtual interface on the host (e.g. veth9999999), which is connected to the eth0 interface of the container.</li>
                    </ul></aside>
                </section>

                <section>
                    <h3>10: Docker networking</h3>
                    <ul>
                        <li>docker0 virtual bridge</li>
                        <li>172.17.42.1/16 by default</li>
                        <li>Part of the 172.16.0.0/12 RFC 1918 space</li>
                        <li>Sets up virtual ether net ports on the host (eg veth31a763b)</li>
                        <li>Sets up a DOCKER Chain in iptables</li>
                        <li>Mounts hosts /etc/resolv.conf and /etc/hosts in containers</li>
                    </ul>
                </section>
                <section>
                    <h3>10: Docker networking</h3>
                    <pre><code data-trim contenteditable>
# try these commands your the host
# use your own container name
$ sudo iptables -L
$ sudo ip addr
$ sudo docker exec -it stoic_ramanujan findmnt
$ sudo cat $(sudo docker exec -it stoic_ramanujan findmnt | grep resolv | awk -F'[][]' '{ print $2 }')
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
nameserver 192.168.2.92
search wgtn.cat-it.co.nz lan
                    </code></pre>
                    <aside class="notes">Shows that the resolv.conf is mounted in the container, as well as iptables rules.</aside>
                </section>
                </section>

                <section>
                <section>
                    <h3>11: Exec vs Attach</h3>
                    <ul>
                        <li>Exec is specifically for running new processes in an already started container, be it a shell or some other process</li>
                        <li>Attach is for attaching to the running process, not for running an extra process in a container</li>
                    </ul>
                </section>
                <section>
                    <h3>11: Exec</h3>
                    <pre><code>docker exec $CONTAINER $COMMAND</code></pre>
                    <ul>
                        <li>The Docker exec command runs a <strong>new</strong> command (process) in a running container</li>
                    </ul>
                </section>
                <section>
                    <h3>11: Attach</h3>
                    <pre><code>docker attach $CONTAINER</code></pre>
                    <ul>
                        <li>Attach lets you view or interact with any running container's primary process (pid 1) </li>
                        <li>You can attach to the same contained process multiple times simultaneously, screen sharing style</li>
                        <li>View the output of your daemonized process</li>
                        <li>Not for running a new process in a container</li>
                    </ul>
                </section>
                </section>

                <section>
                    <h3>Some Concepts</h3>
                    <ul>
                        <li>Buzzwords ahead!</li>
                        <li><a href="http://radar.oreilly.com/2015/06/an-introduction-to-immutable-infrastructure.html">Immutable infrastructure</a></li>
                        <li><a href="https://blog.engineyard.com/2014/pets-vs-cattle">Cattle vs pets</a></li>
                        <li><a href="http://martinfowler.com/bliki/SnowflakeServer.html">Snowflake Servers</a> vs. <a href="http://martinfowler.com/bliki/PhoenixServer.html">Phoenix Servers</a></li>
                    </ul>
                    <aside class="notes"><ul>
                      <li>Immutable architecture: Instead of mutating an instance, replace it with a new one.</li>
                      <li>Pets (nursed back to health) vs. Cattle (replaced when sick)</li>
                      <li>Snowflake (unique) vs. Phoenix (constantly rising from the ashes of its predecessor)</li>
                    </ul></aside>
                </section>

                <!-- Immutable Infrastructure -->
                <section>
                <section>
                    <h3>Immutable Architecture/Infrastructure</h3>
                    <ul>
                        <li>The environment is defined in code</li>
                        <li>If you need to change <em>anything</em> you create a new instance and destroy the old one</li>
                        <li>Docker makes it much more likely you will work in this way</li>
                        <li>Procedural vs Declarative</li>
                    </ul>
                    <aside class="notes">Docker basically forces you to not manually alter servers.</aside>
                </section>
                <!-- Large image slide -->
                <section class="image-slide">
                    <h2>Immutable Architecture</h2>
                    <img src="http://s.radar.oreilly.com/wp-files/2/2015/06/immutable_infrastructure.gif" alt="Immutable Architecture" height="600" width="800">
                </section>
                </section>

                <!-- Microservices -->
                <!--
                <section>
                <section>
                    <h3>Microservices</h3>
                    <p>Cockcrofts definition: Loosely coupled service oriented architecture with bounded contexts</p>
                    <p>Eric Brewers: Microservice boundaries are language boundaries and team boundaries</p>
                </section>
                <section>
                    <h3>Microservices</h3>
                    <ul>
                        <li>A suite of small services, each running in its own process and communicating with lightweight mechanisms</li>
                        <li>Services can be implemented with entirely different stacks</li>
                        <li>Services can be developed, maintained, and updated independently</li>
                        <li>Often use well defined REST APIs to communicate</li>
                        <li>If a message bus/queue is used then its likely to be lightweight (ZeroMQ vs ESB)</li>
                    </ul>
                    <aside class="notes"><ul>
                      <li><a href="http://martinfowler.com/articles/microservices.html">http://martinfowler.com/articles/microservices.html</a></li>
                    </ul></aside>
                </section>
                <section>
                    <h3>Microservices</h3>
                    <ul>
                        <li>Often use a DevOps approach (you build it you run it)</li>
                        <li>Smart endpoints and dumb pipes</li>
                        <li>Decentralized Data Management with eventual consistency</li>
                        <li>Continuous integration and delivery</li>
                        <li>Design for failure (optimize MTTR (mean-time-to-repair))</li>
                    </ul>
                    <aside class="notes">Smart endpoints and dumb pipes: Communication mediums should be as simple/dumb as possible (e.g. simple message queue, REST); the logic should be in the app.</aside>
                </section>
                <section>
                    <h3><a href="https://www.nginx.com/blog/microservices-at-netflix-architectural-best-practices/">Microservices best practices</a></h3>
                    <ul>
                        <li>Create a Separate Data Store for Each Microservice</li>
                        <li>Keep Code at a Similar Level of Maturity</li>
                        <li>Do a Separate Build for Each Microservice</li>
                        <li>Deploy in Containers</li>
                        <li>Treat Servers as Stateless</li>
                    </ul>
                    <aside class="notes"><ul>
                      <li>Separate data stores: Use the best DBMS and schema for each service.</li>
                      <li>When doing new development, create a new microservice, rather than extending the existing one (so that you don't break it or make it less performant). You can merge the microservices later if needed.</li>
                      <li>Stateless: Cattle, not pets.</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>Containers and Microservices</h3>
                    <ul>
                        <li>Containers do not necessarily map to service or application boundaries</li>
                        <li>A microservice will often contain more than one container</li>
                        <li>A container is more like an OO Class - Brendan Burns @ Dockercon 2015</li>
                        <li>A container is a persistent object - Eric Brewer @ OSCon 2015</li>
                    </ul>
                    <aside class="notes">Containers are great for microservices, because they simplify the task of deploying many individual services, each with their own requirements.</aside>
                </section>
                <section>
                    <h3>Containers and Microservices: Requirements</h3>
                    <ul>
                        <li>Sharing among containers (eg filesystems)</li>
                        <li>Atomic co-scheduling of containers</li>
                        <li>Parameterization of containers</li>
                    </ul>
                    <aside class="notes"><ul>
                      <li>Volumes</li>
                      <li>Being able to spin up a bunch of containers together as a unit.</li>
                      <li>Parameters through environment variables for different environments.</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>Microservices - Resources</h3>
                    <ul>
                        <li><a href="http://martinfowler.com/articles/microservices.html">Microservices - Martin Fowler</a></li>
                        <li><a href="https://www.nginx.com/blog/microservices-at-netflix-architectural-best-practices/">Adopting Microservices at Netflix: Lessons for Architectural Design</a></li>
                        <li><a href="https://www.nginx.com/blog/adopting-microservices-at-netflix-lessons-for-team-and-process-design/">Adopting Microservices at Netflix: Lessons for Team and Process Design</a></li>
                        <li><a href="https://www.youtube.com/watch?v=e4jr6Ihz4Qo">Kubernetes: The Path to Cloud Native - Eric Brewer - OSCon 2105</a></li>
                        <li>Nginx blog Building Microservices series: <a href="https://www.nginx.com/blog/introduction-to-microservices/">1</a>,<a href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway">2</a>,<a href="https://www.nginx.com/blog/building-microservices-inter-process-communication/">3</a></li>
                        <li><a href="https://www.nginx.com/blog/microservices-at-netflix-architectural-best-practices/">Microservices best practices</a></li>
                    </ul>
                </section>
                </section>
                -->

                <!--
                <section>
                    <h3>Devops</h3>
                    <ul>
                        <li>You build it you run it</li>
                        <li>With Docker it is easier to make a distinction between who "owns" the service and who "owns" the platform the service runs on</li>
                        <li>Because dev is like production the developer thinks about how it runs in production</li>
                    </ul>
                </section>

                 <!-- Continuous delivery -->
                <section>
                <section>
                    <h3>Continuous delivery</h3>
                    <ul>
                        <li>Automated Pipeline from developer commit to production deploy</li>
                        <li>Requires Continuous Integration where every commit triggers all the tests</li>
                        <li>Requires lots of tests</li>
                    </ul>
                </section>
                <section>
                  <h3>Continuous delivery</h3>
                  <img src="img/ci-diagram.png" alt="Continuous delivery">
                </section>
                <section>
                    <h3>Continuous delivery antipatterns</h3>
                    <ul>
                        <li>Deploying software manually</li>
                        <li>Deploying to a production-like environment only after development is complete</li>
                        <li>Manual configuration of production environments</li>
                        <li>Docker makes it difficult to do any of these</li>
                    </ul>
                </section>
                </section>

                <!-- Where to start? -->
                <!--
                <section>
                <section>
                    <h3>Containers: Where to start?</h3>
                    <ul>
                        <li>Building binaries</li>
                        <li>Prototypes you can share</li>
                        <li>Tutorials</li>
                        <li>Those small snowflakes</li>
                        <li>Build new functionality as microservices</li>
                        <li>Existing components that are already largely independent</li>
                        <li>Mix and match, containerise the bits that make sense</li>
                    </ul>
                </section>
                <section>
                    <h3>Examples</h3>
                    <ul>
                        <li><a href="https://blog.docker.com/2015/07/docker-three-ways-devops-3/">Distributing (scientific) data</a></li>
                        <li><a href="https://github.com/VISIONAI/clouddream">Distributing clouddream</a></li>
                        <li><a href="https://github.com/CenturyLinkLabs/golang-builder">Compiling go</a></li>
                    </ul>
                </section>
                <section class="image-slide">
                    <h2>Bosch Dreaming</h2>
                    <a href="img/Hieronymus_Bosch_003.jpg"><img src="img/Hieronymus_Bosch_003.jpg" alt="Bosch Dream" height="600" width="800"></a>
                </section>
                </section>
                -->

                <!-- ecosystem -->
                <section>
                <section>
                    <h3>Docker ecosystem</h3>
                    <ul>
                        <li>An explosion of tools</li>
                        <li>Hard to keep up</li>
                        <li>Lets have a quick look</li>
                    </ul>
                </section>
                <!-- Large image slide -->
                <section class="image-slide">
                    <h2>Docker ecosystem</h2>
                    <img src="img/docker-ecosystem.png" alt="Docker Ecosystem" height="600" width="800">
                    <aside class="notes"><ul>
                      <li>Orchestration: Managing the lifecycle of containers (starting, stopping, etc.) and distributing them across hosts in a cluster.</li>
                      <li>Service Discovery: Manage directories of where services running in containers can find each other in a cluster of hosts.</li>
                      <li>Networking: Virtual networks across hosts in a cluster</li>
                      <li>Linux: Underlying Linux technologies that Docker uses.</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>The stack</h3>
                    <ul>
                        <li>The LAMP stack equivalent</li>
                        <li>Container Orchestration Engines</li>
                        <li>Linux - Docker - COE - ?</li>
                        <li>Often LDK (Linux - Docker - Kubernetes)</li>
                        <li>Higher level projects build on this stack (eg OpenShift and CloudFoundry)</li>
                    </ul>
                </section>
                <section>
                    <h3>Docker ecosystem - Host OS</h3>
                    <p>Lightweight operating systems designed to run containers</p>
                    <ul>
                        <li><a href="https://coreos.com/">CoreOS</a> (systemd)</li>
                        <li><a href="http://www.projectatomic.io/">Project Atomic</a> (cut down RHEL)</li>
                        <li><a href="http://rancher.com/">Rancher</a> (Dockers all the way down)</li>
                        <li><a href="http://boot2docker.io/">boot2docker</a> (for windows/mac devs)</li>
                    </ul>
                </section>
                <section>
                    <h3>Docker ecosystem - Container Orchestration Engines</h3>
                    <p>Engine for orchestrating container workloads, term comes from the OpenStack Magnum project.</p>
                    <p>There are two main classes of orchestration tooling:</p>
                    <ul>
                        <li><strong>Simple orchestration tools</strong> for deploying on pet servers</li>
                        <li><strong>Distributed schedulers</strong> for deploying on cattle server farms</li>
                    </ul>
                </section>
                <section>
                    <h3>Simple orchestration tools</h3>
                    <ul>
                        <li>Tools to simply deploy containers onto servers.</li>
                        <li>Simple way to get many benefits of Docker in production.</li>
                        <li>E.g. Centurion, Helios, Docker modules for Ansible and Puppet.</li>
                    </ul>
                </section>
                <section>
                  <h3>Docker + Ansible Deployments</h3>
                  <img src="img/docker-ansible-diagram.png" height="600">
                </section>
                <section>
                    <h3>Distributed schedulers</h3>
                    <ul>
                        <li>Make a cluster appear to be a single computer.</li>
                        <li>More complex, but have more of the benefits associated with immutable infrastructure, etc.</li>
                        <li><a href="http://radar.oreilly.com/2015/10/swarm-v-fleet-v-kubernetes-v-mesos.html">Swarm v. Fleet v. Kubernetes v. Mesos</a></li>
                    </ul>
                </section>
                </section>

                <!-- Docker compose -->
                <section>
                <section>
                    <h3>Docker compose</h3>
                    <ul>
                        <li>Mainly used for spinning up multi-container development/testing environments.</li>
                        <li>You deploy <strong>stacks</strong> made up of <strong>services</strong>
                          <ul>
                            <li>One container for each service (for compose)</li>
                          </ul></li>
                        <li>Comparable to Vagrant for developer environments</li>
                        <li>Several different file version standards of compose files (latest is version 3)</li>
                    </ul>
                </section>
                <section>
                    <h3>docker-compose.yml</h3>
                    <pre><code>version: "3"
services:
  web:
    image: training/webapp
    ports:
      - "8000:80"
    networks:
      - webnet
  redis:
    image: redis
    ports:
      - "6379:6739"
    volumes:
      - ./data:/data
    networks:
      - webnet
networks:
  webnet:</code></pre>
                </section>
                <section>
                    <h3>Docker compose - hands on</h3>
                    <pre><code>git clone https://github.com/ben-denham/docker-compose-demo.git
cd docker-compose-demo

cat docker-compose.yml

docker-compose up</code></pre>
                </section>
                </section>

                <!-- Docker swarm -->
                <section>
                <section>
                    <h3>Docker swarm</h3>
                    <ul>
                        <li>Native clustering for Docker</li>
                        <li>Manage a cluster of Docker engines without any additional tools</li>
                        <li>Turn a group of Docker engines into a single, virtual Docker engine</li>
                    </ul>
                </section>

                <section>
                  <h3>Creating a Swarm</h3>

                  <pre><code># Start a swarm "manager"
$ sudo docker swarm init --advertise-addr 192.168.99.100
Swarm initialized: current node (dxn1zf6l61qsb1josjja83ngz) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \
    192.168.99.100:2377

To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.

# View Swarm state
$ sudo docker info
$ sudo docker node ls</code></pre>

                  <a href="http://docs.catalystcloud.io/tutorials/docker-getting-started-with-swarm-mode-tutorial-on-the-catalyst-cloud.html">Docker Swarm on the Catalyst Cloud Tutorial</a>
                </section>

                <section>
                  <h3>Running containers in a Swarm</h3>

                  <pre><code># Run a container
sudo docker service create --replicas 3 --name helloworld --publish 5000:5000 training/webapp

sudo docker service ls # View running "services"
sudo docker service ps helloworld # View containers for service
sudo docker service inspect helloworld # View service configuration

# Scale the service
sudo docker service scale helloworld=5

# Apply a rolling update
sudo docker service update --image training/webapp:latest helloworld

# Remove the service
sudo docker service rm helloworld</code></pre>

                </section>

                <section>
                  <h3>Swarm Mesh Routing</h3>

                  <img src="img/ingress-routing-mesh.png">
                </section>

                <section>
                  <h3>docker-compose.yml - with "deploy" configuration</h3>

                  <pre><code>version: "3"
services:
  web:
    image: training/webapp
    ports:
      - "8000:80"
    networks:
      - webnet
    deploy:
      replicas: 5
      restart_policy:
        condition: on-failure
      resources:
        limits:
          cpus: "0.1"
          memory: 50M
  redis:
    image: redis
    ports:
      - "6379:6739"
    volumes:
      - ./data:/data
    networks:
      - webnet
    deploy:
      placement:
        constraints: [node.role == manager]
networks:
  webnet:</code></pre>
                </section>

                <section>
                  <h3>Running a stack in a Swarm</h3>

                  <pre><code># Run a stack
sudo docker stack deploy -c swarm-compose.yml webstack

sudo docker stack ls # View running "stacks"
sudo docker stack services webstack # View services in a stack
sudo docker stack ps webstack # View containers in a stack

# Scale or apply a rolling update
sudo docker stack deploy -c swarm-compose.yml webstack

# Remove the service
sudo docker stack rm webstack</code></pre>

                </section>

                <section>
                  <h3>Leaving the Swarm</h3>

                  <pre><code>sudo docker swarm leave
# If it's the last manager
sudo docker swarm leave --force</code></pre>
                </section>

                </section>

                <section>
                  <section>
                    <h3>Summary of Docker Products</h3>

                    <ul>
                      <li>Docker Engine
                        <ul><li>The actual programme for running containers</li></ul></li>
                      <li>Docker Compose
                        <ul><li>Run a "stack" of containers</li></ul></li>
                      <li>Docker Swarm
                        <ul>
                          <li>Manage a cluster of Docker Engines as a single, virtual Docker Engine</li>
                          <li>Now part of Docker Engine</li>
                        </ul></li>
                      <li>Docker Machine
                        <ul>
                          <li>Remotely provision and use a Docker engine on another machine</li>
                          <li>Previously used for Mac and Windows</li>
                        </ul></li>
                      <li>Docker for Mac and Windows
                        <ul>
                          <li>Include a lightweight Linux VM</li>
                          <li>Supersede Docker Toolbox</li>
                        </ul></li>
                    </ul>
                  </section>
                  <section>
                    <h3>Summary of Docker Products</h3>

                    <ul>
                      <li>Docker Hub
                        <ul>
                          <li>Registry as a Service; Appears to be superseded Store and Cloud</li>
                        </ul></li>
                      <li>Docker Store
                        <ul><li>Download free and commercial images</li></ul></li>
                      <li>Docker Cloud
                        <ul><li>Registry+Build+Testing as a Service</li></ul></li>
                      <li>Docker Registry
                        <ul><li>Host your own repository of images</li></ul></li>
                      <li>Docker Notary
                        <ul><li>Tool for verifying/trusting images</li></ul></li>
                      <li>Docker EE vs Docker CE
                        <ul><li>Docker now has a supported enterprise edition with exclusive features</li>
                        <li>Docker community edition remains open-source</li></ul></li>
                      <li>Docker Datacenter
                        <ul><li>Easily deploy Docker EE in a datacenter or cloud environment</li></ul></li>
                    </ul>
                  </section>
                </section>

                <!-- Kubernetes -->
                <section>
                <section>
                    <h3>Kubernetes</h3>
                    <ul>
                        <li>Container orchestrator</li>
                        <li>Started by Google</li>
                        <li>Inspired by Borg (Google's cluster management system)</li>
                        <li>Open source project written in Go</li>
                        <li>Cloud Native Computing Foundation</li>
                        <li>Manage applications not machines</li>
                        <li>Available as a service</li>
                    </ul>
                </section>
                <!--
                <section>
                    <h3>Kubernetes Components</h3>
                    <ul>
                        <li>Pods - an ephemeral group of co-scheduled containers that together provide a service</li>
                        <li>Flat Networking Space - each pod has an IP and can talk to other pods, within a pod containers communicate via localhost (need to manage ports)</li>
                        <li>Labels - Key value pairs, used to label pods and other objects so the scheduler can operate on them</li>
                        <li>Services - stable endpoints comprised of one or more pods (external services are supported)</li>
                        <li>Replication Controllers - the orchestrator that controls and monitors the pods within a service (known as replicas)</li>
                    </ul>
                </section>
                -->
                <section>
                  <h3>Kubernetes Overview</h3>
                  <img src="img/kubernetes-diagram.png" alt="Kubernetes diagram">
                  <aside class="notes">The services and controllers actually run as processes on every node. The external load balancer is necessary to split traffic across the nodes, and once it reaches a node, the service will route it to the correct pod, or even a different node (see: http://www.dasblinkenlichten.com/kubernetes-101-external-access-into-the-cluster/).</aside>
                </section>
                <!--
                <section>
                    <h3>Pods/Services</h3>
                    <ul>
                        <li>Co-locate containers</li>
                        <li>Shared volumes</li>
                        <li>IP address (important for port space and migration)</li>
                        <li>Unit of deployment and migration</li>
                        <li>Easy migration = high utilisation</li>
                        <li>Scale service by scaling pods</li>
                    </ul>
                </section>
                -->
                </section>

                 <!-- Managing state -->
                <section>
                <section>
                    <h3>Managing State</h3>
                    <p>"In a cluster of ephemeral containers application state must exist outside of the containers."</p>
                    <p>Ian Lewis, Google - <a href="https://speakerdeck.com/ianlewis/in-a-world-of-ephemeral-containers-how-do-we-keep-track-of-things-at-openstack-summit-tokyo">In a World of Ephemeral Containers, How Do We Keep Track of Things? @ OpenStack Summit Tokyo</a> (<a href="https://www.youtube.com/watch?v=aYs7IxMQzgg">video</a>)</p>
                </section>
                <section>
                    <h3>Initial state</h3>
                    <p>All containers start with exactly the same state which is derived from the image they are instantiated from.</p>
                </section>
                <section>
                    <h3>What exactly is state?</h3>
                    <ul>
                    </ul>
                </section>
                <section>
                    <h3>What exactly is state?</h3>
                    <ul>
                        <li>Our Database!</li>
                    </ul>
                </section>
                <section>
                    <h3>What exactly is state?</h3>
                    <ul>
                        <li>Our Database!</li>
                        <li>Filesystem (volumes)</li>
                    </ul>
                </section>
                <section>
                    <h3>What exactly is state?</h3>
                    <ul>
                        <li>Our Database!</li>
                        <li>Filesystem (volumes)</li>
                        <li>Configuration (service discovery)</li>
                    </ul>
                </section>
                <section>
                    <h3>What exactly is state?</h3>
                    <ul>
                        <li>Our Database!</li>
                        <li>Filesystem (volumes)</li>
                        <li>Configuration (service discovery)</li>
                        <li>Secrets</li>
                    </ul>
                </section>
                <section>
                    <h3>What exactly is state?</h3>
                    <ul>
                        <li>Our Database!</li>
                        <li>Filesystem (volumes)</li>
                        <li>Configuration (service discovery)</li>
                        <li>Secrets</li>
                        <li>Source Code?</li>
                    </ul>
                </section>
                <section>
                    <h3>Managing Volumes</h3>
                    <ul>
                        <li>Normal Docker volumes are per host</li>
                        <li>Kubernetes Persistent volumes</li>
                        <li>Docker Engine 1.9 includes redesigned volume system with more plugins (eg <a href="https://clusterhq.com/flocker/introduction/">Flocker</a>)</li>
                    </ul>
                </section>
                <section class="image-slide">
                    <h2>Managing state - CAP</h2>
                    <p>Managing state can be tricky</p>
                    <img src="img/cap.png" alt="CAP" height="600" width="800">
                    <aside class="notes">
                      Managing state in clustered environments is not
                      unique to Docker. There are many database
                      solutions, each with its own pros and cons.
                    </aside>
                </section>
                <section>
                    <h3>Patterns for Managing State</h3>
                    <ul>
                        <li>Orchestrator-specific secret functionality
                          <ul>
                            <li>eg Swarm secrets</li>
                          </ul></li>
                        <li>Outside the cluster (SEP)</li>
                        <li>Adapted to run in cluster (eg MySQL inside cluster with data volume for persistence)
                          <ul>
                            <li>Constrain the container to a single node</li>
                            <li>Share the volume with all nodes (eg NFS)</li>
                          </ul></li>
                        <li>Cluster native (eg Cassandra or Riak)</li>
                        <li><a href="http://vitess.io/">vitess.io</a></li>
                    </ul>
                </section>
                </section>

                <section>
                <section>
                    <h3>Patterns for Composite Containers</h3>
                    <p>
                    <a href="http://blog.kubernetes.io/2015/06/the-distributed-system-toolkit-patterns.html">http://blog.kubernetes.io/2015/06/the-distributed-system-toolkit-patterns.html</a> (<a href=blog/">local</a>).
                    </p>
                    <ul>
                        <li>Sidecar containers (eg logger, git synchroniser)</li>
                        <li>Ambassador containers (local proxy to a service of unknown size)</li>
                        <li>Adapter containers (normalize and abstract different services)</li>
                    </ul>
                </section>
                <section class="image-slide">
                    <h2>Sidecar containers</h2>
                    <ul>
                        <li>Modular and pluggable</li>
                        <li>Reuse sidecar for different frontends</li>
                        <li>Different team can maintain the sidecar</li>
                        <li>Lower complexity inside specific containers</li>
                    </ul>
                    <img src="img/sidecar.png" alt="Sidecar">
                    <aside class="notes">
                      Sidecar containers provide re-usable
                      functionality that enhances
                      another container.
                      <br>
                      The example here shows a webserver container server files from
                      a data volume. The data volume is shared with a
                      sidecar container that synchronises the files
                      with a Git repository, thus providing Git
                      push-to-deploy. The sidecar can be re-used to
                      provide git-syncing in other contexts.
                    </aside>
                </section>
                <section class="image-slide">
                    <h2>Ambassador containers</h2>
                    <ul>
                        <li>Its a proxy ...</li>
                        <li>The solution behind the proxy can be as simple or complicated as the environment requires</li>
                        <li>Also modular, reuse, lower complexity per container</li>
                    </ul>
                    <img src="img/ambassador.png" alt="Ambassador">
                    <aside class="notes">
                      Example is of an ambassador container to act
                      like a normal redis server, while it is really a
                      proxy for a redis cluster.
                    </aside>
                </section>
                <section class="image-slide">
                    <h2>Adapter containers</h2>
                    <ul>
                        <li>When containers want to talk to other systems</li>
                        <li>Use adaptors to translate so that neither ends needs native support for each other protocols</li>
                        <li>eg, monitoring systems, convert from app specific output to monitoring system format</li>
                    </ul>
                    <img src="img/adapter.png" alt="Adapter">
                    <aside class="notes">
                      In the example, the redis logs are converted
                      into a standard format by an adapter container,
                      so that the monitoring system only needs to know
                      the standard format that all adapters provide.
                    </aside>
                </section>
                </section>

                <!-- Security -->
                <section>
                <section>
                    <h3>Security</h3>
                    <ul>
                        <li>How do you keep track of all the versions of all the software in all the containers?</li>
                        <li>The way to apply security updates is to update the base image, then rebuild your application image</li>
                        <li>If you release often then include an updated base every time you release (plus special releases for heartbleeds)</li>
                        <li>If you release infrequently then do base update releases of your app</li>
                    </ul>
                </section>
                <section>
                    <h3>Security - Image Signing</h3>
                    <ul>
                        <li><a href="https://blog.docker.com/2015/08/content-trust-docker-1-8/">Intoduction to Docker Content Trust</a></li>
                        <li>Provided by the <a href="https://github.com/docker/notary">Notary</a> open source project</li>
                        <li>Based on <a href="http://theupdateframework.com/">The Update Framework</a></li>
                        <li><a href="https://www.youtube.com/watch?v=at72dhg-SZY&feature=youtu.be&t=4873">Video</a></li>
                        <li><a href="https://docs.docker.com/engine/security/trust/content_trust/">Content Trust Documentation</a></li>
                    </ul>
                    <aside class="notes"><ul>
                      <li>Notary is a general purpose tool for signing files.</li>
                      <li>You can enable "Docker Content Trust" so that you can sign images that other Docker uses can verify.</li>
                      <li>Currently only available with DockerHub.</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>Security - Image Vulnerability Scanning</h3>
                    <ul>
                        <li><a href="https://coreos.com/blog/vulnerability-analysis-for-containers/">Intoduction to Clair from CoreOS</a></li>
                        <li><a href="https://github.com/coreos/clair">Clair on github</a></li>
                        <li>Project Nautilus a new image scanning and vulnerability detection service for Official Repos on Docker Hub</li>
                    </ul>
                </section>
                <section>
                    <h3>Security - Useful links</h3>
                    <ul>
                        <li>How often do the official base images get updated? (details <a href="https://blog.docker.com/2015/06/understanding-official-repos-docker-hub/">here</a>)</li>
                        <li><a href="https://titanous.com/posts/docker-insecurity">Image signing</a> (see <a href="https://github.com/docker/notary">notary</a>)</li>
                        <li><a href="https://securityblog.redhat.com/2014/12/17/container-security-isolation-heaven-or-dependency-hell/">Level of isolation</a></li>
                        <li><a href="https://d3oypxn00j2a10.cloudfront.net/assets/img/docker%20Security/WP_Intro_to_container_security_03.20.2015.pdf">Introduction to Container Security</a> Whitepaper</li>
                        <li><a href="https://blog.docker.com/2013/08/containers-docker-how-secure-are-they/">Fundamentals</a> (old but informative)</li>
                        <li><a href="http://linux-audit.com/docker-security-best-practices-for-your-vessel-and-containers/">Best practices</a></li>
                        <li><a href="https://securityblog.redhat.com/2014/12/18/before-you-initiate-a-docker-pull/">Securely downloading containers</a></li>
                    </ul>
                    <aside class="notes"><ul>
                      <li>Information about official repos</li>
                      <li>Existing issues with image verification.</li>
                      <li>Limitations of containers (Shared kernel etc.)</li>
                      <li>Whitepaper on container security</li>
                      <li>Explanation of how Docker works, security implications, and comparisons to VMs and other containerization systems.</li>
                      <li>Best practice recommendations</li>
                      <li>Problems with Docker pull (auto-unpacking), and how to work around it.</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>Other problems</h3>
                    <ul>
                        <li>Not declarative (Dockerfiles)</li>
                        <li>Not idempotent or repeatable (E.g. apt-get install)</li>
                        <li><a href="https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/">Pids and spawning issues</a> (Zombie processes)</li>
                        <li>Standardisation</li>
                        <li>See <a href="https://www.youtube.com/watch?v=wpFrkq5XNFM">these</a> <a href="https://www.youtube.com/watch?v=et7BCV_kAUY">talks</a> from systemd.conf</li>
                    </ul>
                </section>
                </section>

                <section>
                <section>
                    <h3>Monitoring</h3>
                    <p>Q: How can I monitor my containers?</p>
                    <p>A: Try sysdig/csysdig</p>
                    <ul>
                        <li>sudo csysdig</li>
                        <li>hit F2 and choose the Containers view</li>
                        <li>can also monitor <a href="http://blog.kubernetes.io/2015/11/monitoring-Kubernetes-with-Sysdig.html">kubernetes</a></li>
                    </ul>
                    <aside class="notes">csysdig has a curses UI.</aside>
                </section>
                <section>
                    <h3>Monitoring</h3>
                    <p>Lets build a Docker image for some testing:</p>
                    <pre><code data-trim contenteditable>
$ cat dockerfiles/stress-testing/Dockerfile
$ sudo docker build -t stress-test dockerfiles/stress-testing/
$ sudo docker run stress-test stress --help
$ sudo docker run [DOCKER OPTIONS] stress-test stress [STRESS OPTIONS]
                    </code></pre>
                </section>
                <section>
                    <h3>Monitoring and CPU limits</h3>
                    <p>Run this command while watching csysdig and htop in other terminals</p>
                    <pre><code data-trim contenteditable>
$ sudo docker run --cpuset-cpus=0,1 stress-test stress -c 3
# in another terminal
$ sudo csysdig
# in another terminal
$ sudo htop
                    </code></pre>
                    <aside class="notes">
                      Here we limit Docker to using the first 2 CPUs (0 and 1).
                      <br>
                      htop shows usage per CPU.
                    </aside>
                </section>
                <section>
                    <h3>Monitoring and Memory limits</h3>
                    <p>Run this command while watching csysdig and htop in other terminals</p>
                    <pre><code data-trim contenteditable>
$ sudo docker run -m 512M stress-test stress --vm-bytes 256M -m 4
# in another terminal
$ sudo csysdig
# in another terminal
$ sudo htop
                    </code></pre>
                    <aside class="notes">
                      Limit the container to 512MB of RAM and 512MB of swap.
                    </aside>
                </section>
                <section>
                    <h3>Monitoring - check-config</h3>
                    <p>How to enable swap limiting:</p>
                    <pre><code data-trim contenteditable>
$ check-config.sh # Check that the kernel supports it.
# Edit /etc/default/grub:
# GRUB_CMDLINE_LINUX="cgroup_enable=memory swapaccount=1"
                    </code></pre>
                    <a href="https://github.com/moby/moby/blob/master/contrib/check-config.sh">check-config.sh</a>
                </section>
                </section>

                <section>
                <section>
                    <h3>FAQ</h3>
                    <ul>
                        <li><a href="http://www.projectatomic.io/blog/2015/08/why-we-dont-let-non-root-users-run-docker-in-centos-fedora-or-rhel/">Why is sudo required?</a></li>
                        <li><a href="http://www.projectatomic.io/blog/2015/07/what-are-docker-none-none-images/">What are the &lt;none&gt;&lt;none&gt; images I see and how can I clean them up?</a></li>
                        <li><a href="https://docs.docker.com/articles/baseimages/">Can I build my own base image?</a></li>
                        <li><a href="https://stackoverflow.com/questions/24394243/why-are-docker-container-images-so-large">Why are Docker images so large?</a></li>
                        <li><a href="http://thenewstack.io/understanding-the-docker-cache-for-faster-builds/">Does each Dockerfile run command create its own layer?</a></li>
                        <li><a href="https://blog.docker.com/2015/11/docker-multi-host-networking-ga/">What happened to Docker links?</a></li>
                    </ul>
                    <aside class="notes"><ul>
                      <li>sudo is required for kernel features</li>
                      <li>Dangling images (name has been re-used for another image).</li>
                      <li>There is a guide</li>
                      <li>All dependencies from all layers, clean up package manager files to reduce size.</li>
                      <li>Yes</li>
                      <li>Docker's networking has been re-worked to not use links.</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>FAQ</h3>
                    <p>Q: Whats the story with Docker top pids?</p>
                    <pre><code data-trim contenteditable>
$ sudo docker top sleepy_cori
UID  PID   PPID C STIME TTY    TIME     CMD
root 30136 2379 0 12:29 pts/32 00:00:00 /bin/bash

$ pstree -s -p $(sudo docker top sleepy_cori | tail -1 | awk '{ print $2 }')
init(1)───docker(2379)───bash(30136)
                    </code></pre>
                    <p>A: Top pids are host pids not namespaces container pids</p>
                </section>
                <section>
                    <h3>FAQ</h3>
                    <p>Q: Should I include my application source code in the image?</p>
                    <p>A: It depends, some people like to mount application source code as <a href-"http://blog.ionic.io/docker-hot-code-deploys/">volume</a>, others checkout source code when <a href="http://michal.karzynski.pl/blog/2015/04/19/packaging-django-applications-as-docker-container-images/">building the image</a>.</p>
                    <p>If you are checking out source code in your Dockerfile you need to be aware of <a href="http://thenewstack.io/understanding-the-docker-cache-for-faster-builds/">how caching works</a>.</p>
                </section>
                <section>
                    <h3>FAQ: Copy vs. Add</h3>
                    <p>Q: Should I use Copy or Add in my Dockerfile?</p>
                    <p>A: Use copy unless you actually need the magic add provides (details <a href="https://labs.ctl.io/dockerfile-add-vs-copy/">here</a>).</p>
                </section>
                <section>
                    <h3>FAQ: Docker on the Catalyst Cloud</h3>
                    <p>Q: Whats the easiest way to use Docker on the Catalyst Cloud?</p>
                    <p>A: Have a look at <a href="http://docs.catalystcloud.io/tutorials.html#using-docker-machine-on-the-catalyst-cloud">this tutorial</a> on how to use Docker machine to provision Docker engines on the the Catalyst Cloud</p>
                </section>
                <section>
                    <h3>FAQ: Stop vs. Remove</h3>
                    <p>Q: Are container really ephemeral?</p>
                    <p>A: Stopping a container does not delete its filesystem, it will still be there in /var/lib/docker when you start it again. You need to call Docker rm to delete a container</p>
                </section>
                <section>
                    <h3>FAQ: Mounting volumes in running containers</h3>
                    <p>Q: Can I mount a volume in a running container?</p>
                    <p>A: Its <a href="https://github.com/docker/docker/issues/9849">not currently supported</a> by the CLI but there are some <a href="https://jpetazzo.github.io/2015/01/13/docker-mount-dynamic-volumes/">hacks</a> out there.</p>
                </section>
                <section>
                    <h3>FAQ: History</h3>
                    <p>Q: Can you tell me more about the history of containers and their underlying technologies?</p>
                    <p>A: Watch <a href="https://www.youtube.com/watch?v=YsYzMPptB-k">this talk</a> by Kernel developer James Bottomley at the Tokyo OpenStack summit</p>
                </section>
                <section>
                    <h3>FAQ: Exec vs. shell CMD</h3>
                    <p>Q: Why is it better to use the exec version rather than the shell version of CMD/ENTRYPOINT?</p>
                    <p>A: As our command is not pid 1 we cannot send POSIX signals to our command</p>
                    <p>A: /bin/sh may not be available in minimal containers</p>
                    <p>More info <a href="https://www.ctl.io/developers/blog/post/dockerfile-entrypoint-vs-cmd/">here</a></p>
                    <p>More info about signals <a href="https://labs.ctl.io/gracefully-stopping-docker-containers/">here</a></p>
                </section>
                <section>
                    <h3>FAQ: Docker log rotation</h3>
                    <p>Q: Is logfile rotation configurable?</p>
                    <p>A: <a href="https://docs.docker.com/engine/reference/logging/overview/">Yes</a>.</p>
                </section>
                <section>
                    <h3>FAQ: Digest broken?</h3>
                    <p>Q: Why does the digest command not work?</p>
                    <p>A: You tell me ...</p>
                </section>
                <section>
                    <h3>FAQ: RUN command chaining</h3>
                    <p>Q: Why do you see so many commands chained together on Dockerfile RUN lines?</p>
                    <p>A: There used to be a limited number of layers (was 42 now 127)</p>
                    <p>A: Minimising layers is <a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">encouraged</a></p>
                    <p>A: Multiple RUN lines can lead to caching related <a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">problems</a></p>
                </section>
                </section>

                <section>
                <section>
                    <h3>Next steps</h3>
                    <p>What would you like to see in an intermediate Docker course?</p>
                </section>
                <section>
                    <h3>Next steps</h3>
                    <ul>
                        <li>Setup private registry</li>
                        <li>Students build custom "microservices"</li>
                        <li>Setup CoreOS on OpenStack</li>
                        <li>Deploy students microservices and create a www router service</li>
                        <li>Define service as a kubernetes pod/service</li>
                        <li>Scale and migrate pods (between OpenStack regions?)</li>
                        <li>Continuous delivery?</li>
                        <li>Let me know!</li>
                    </ul>
                </section>
                </section>

                <section>
                    <h3>Sources</h3>
                    <p>Sources of the material used in this course:</p>
                    <ul>
                        <li><a href="https://docs.docker.com/">https://docs.docker.com/</a></li>
                        <li><a href="https://training.docker.com/introduction-to-docker">https://training.docker.com/introduction-to-docker</a></li>
                        <li><a href="http://alandargan.com/using-vagrant-docker/">http://alandargan.com/using-vagrant-docker/</a></li>
                        <li><a href="http://blog.octo.com/en/docker-registry-first-steps/">http://blog.octo.com/en/docker-registry-first-steps/</a></li>
                        <li><a href="https://www.digitalocean.com/community/tutorials/the-docker-ecosystem-an-introduction-to-common-components">https://www.digitalocean.com/community/tutorials/the-docker-ecosystem-an-introduction-to-common-components</a></li>
                        <li><a href="http://radar.oreilly.com/2015/07/set-up-kubernetes-with-a-docker-compose-one-liner.html">http://radar.oreilly.com/2015/07/set-up-kubernetes-with-a-docker-compose-one-liner.html</a></li>
                        <li><a href="http://www.linuxjournal.com/content/concerning-containers-connections-docker-networking">http://www.linuxjournal.com/content/concerning-containers-connections-docker-networking</a></li>
                    </ul>

                </section>
    <section>
        <h3>Basic Docker Examples</h3>
        <ul>
            <li>Run "Hello, World" in a container</li>
            <li>Interact with a container</li>
            <li>Daemonise a container</li>
        </ul>
    </section>
    <section>
        <h3>More Examples</h3>
    </section>

                    <section>
                        <h3>Persist changes to a container</h3>
                        <pre>$ docker run -t -i ubuntu:14.04 /bin/bash

root@69079aaaaab1:/# apt-get update

$ docker commit 69079aaaaab1 ubuntu:update
13132d42da3cc40e8d8b4601a7e2f4dbf198e9d72e37e19ee1986c280ffcb97c

$ docker images
REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE
ubuntu update 13132d42da3c 5 days ago 213 MB

$ docker diff &lt;container&gt;
                        </pre>

                    </section>
                    <section>
                        <h3>Saving an image as tar for sharing</h3>
                        <pre>$ docker ps -a

CONTAINER ID IMAGE COMMAND CREATED ... NAMES
77d9619a7a71 ubuntu:14.04 "/bin/bash" 10 seconds ago ... high_shockley

$ docker export 77d9619a7a71 > update.tar
$ ls
update.tar

$ docker import - update &lt; update.tar
157bcbb5fdfce0e7c10ef67ebdba737a491214708a5f266a3c74aa6b0cfde078

$ docker images
REPOSITORY TAG IMAGE ID ... VIRTUAL SIZE
update latest 157bcbb5fdfc ... 188.1 MB
                        </pre>
                    </section>
        </div>


        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>

            // Full list of configuration options available here:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
                transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none

                // Parallax scrolling
                // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
                // parallaxBackgroundSize: '2100px 900px',

                // Optional libraries used to extend on reveal.js
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
                ]
            });

        </script>

    </body>
</html>
